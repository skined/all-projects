<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title></title>
</head>
<body>
<script type="text/javascript">
	//对象是什么 万物皆对象
	// var obj={
	// 	name:'xiaolong',
	// 	age:34,
	// 	health:100,
	// 	smoke:function(){
	// 		obj.health--;
	// 		console.log("o0o");
	// 	},
	// 	drink:function(){
	// 		obj.health++;
	// 		console.log("干杯！");
	// 	}
	// };
	// obj.sex='男';
	// delete obj.sex;
	// console.log(obj);
	// 3.对象创建的方式有两种
	// （1）对象字面量/对象直接量
	// （2）构造函数
	//   （1系统自带的构造函数
	//    （2自定义的构造函数
	// var obj=new Object();
	// console.log(typeof obj);
	//构造函数需要大驼峰命名方式
	// 对象没实例化一次创建一个新的对象
	// 只有在new的时候才会发生出构造函数创建处对象	
	// function Test(){
	// 	this.name='liliang';
	// 	this.age=34,
	// 	this.sex='nan',
	// 	this.health=100;
	// 	this.say=function(){
	// 		alert(123);
	// 	};
	// 	this.smoke=function(){
	// 		health--;
	// 	}
	// }
	// var obj=new Test();
	// var obj1=new Test();
	// obj.age=24;
	// console.log(obj.smoke);
	//构造函数需要打驼峰命名方式
	// function Test(){
	// 	this.name='lixiaolong';
	// 	this.age=23;
	// 	this.sex='nan';
	// 	this.health=100;
	// 	this.say=function(){
	// 		alert('123');
	// 	};
	// 	this.smoke=function(){
	// 		health--;
			
	// 	};
	// 	this.drink=function(){
	// 		health++;
			
	// 	}
	// }
	// var obj=new Test();
	// //var obj1=new Test();
 //    obj.age=24;
 //    console.log(obj.health)
 //    console.log(obj.smoke);
 //    console.log(obj.drink);


 //没实例化一次，创建一个新的对象
 //构造函数内部原理
 //构造函数构建出对象时，需要new，有了new之后会产生构造函数的三段式
 //1.在函数的最前面创建隐式this={}
 //2.执行this.name='liliang',给this副属性
 //3.隐式三段返回this
 //4.在构造函数new实例的时候，如果内部return的是值类型，会被忽略，而引用类型
 //会影响对象的属性
 // function Person(name,age,height){
 // 	//Person不是一个方法，不可直接调用
 // 	this.name=name;
 // 	this.age=age;
 // 	this.height=height;
 // 	return;
 // }
 // var lubu=new Person('吕布',23,222);
 // var luzshen=new Person("鲁智深",25,465);
 // var wus=new Person("诉讼",026,256);
//字符串调数组的方法
//name调数组的方法

// var m=new Number(213);
// m=m+1;
// console.log(typeof m);
//1.包装类
//1.new Number()
//2.new String()
//3.new Boolean()


// var str='abcd';
// str.length=2;
// 1.new String('abcd').length;
// 2.delete
//取length，给length赋值，然后删除
//console.log(str.length);
// 1.new String('abcd').length;
// 2.delete


// var x=1;
// var x=z=0;
// function add(n){
// 	return n=n+1;
// }
// y=add(x);
// function add(n){
// 	return n=n+3;
// }
// z=add(x);
// console.log(x,y,z);
// 求xyz;	




// var str='abc';
// str+=1;
// var test=typeof(str);
// // var str=str+1='abc'+1;
// // console.log(test);
// // new String("abc").length;
// // delte;
// if(test.length==6){
// 	test.sign='我是string';
// }
// console.log(test.sign);



// function Person(){
// 	var a=0;
// 	this.name=name;
// 	function ccc(){
// 		a++;
// 		console.log(a);
// 	}
// 	this.say=ccc;
// }
// var person=new Person();
// person.say();




// charCodeAt();  /0~65535 unicode码的位置
//var
// var str='adsdss1232大方快雕塑打开'
// //unicode 0-255 1B
// //unicode 255以上 2B
// function abc(str){
// var num=0;
// for(i=0;i<str.length;i++){
//   if(str[i].charCodeAt<=255){
//   		num++;
// }else{
// 	num+=2;
// }

// }
// return num;
//   }

// console.log(abc("adsdss1232大方快雕塑打开"));


//console.log(isNaN("dsa"));

// function demo(a){
// 	if(typeof(a)=='number' || typeof a=='boolean'){
// 		console.log("false");
// 	}else if(typeof a=='object' || typeof a=='undefined' || typeof a!='number'){
// 		console.log("true");
// 	}
// }
// demo(true);


//方法二:
// isNaN("addsdsds");
// function myisNaN(str){
// 	var isNaN=Number(str);
// 	isNaN+='';
// 	if(isNaN='NaN'){
// 		return false;
// 	}
// 	else{
// 		return false;
// 	}
// }


//引用值可以操作属性 数组带砍断属性，原型不能操作属性
// var arr=[1,23,45,5];
// console.log(arr.length);
// arr.length=3;
// console.log(arr);



//原型链/原型
//1.定义:原型式function对象的一个属性，他定义了构造函数制造出来的对象的共有的祖先，通过该函数产生的对象，可以继承该原型的属性和方法，原型也是个对象
//2.利用原型特点可以提取该属性
//3.对象如何查看该属性__proto__(隐式属性)
//4.对象查看对象的给构造函数constructor
//增删改查只有差可以简单读取原型2中的属性
//原型是实力出来构造函数制造出来对象的共有祖先
//console.log(Person.prototype);
//prototype原型类型
// Person.prototype.name='比利王去世';
// function Person(){
// 	this.name='xyz';
// }
// var obj=new Person();
// console.log(obj.name);
// console.log(Person.prototype.name);
//原型是该函数的一个属性，调用函数的属性在该函数中没有时可以调用原型函数中的属性



// function  Shell(scolor,ssize){
// 	this.scolor=scolor;
// 	this.ssize=ssize;
// }
// function Battery(Bstyle,Bssize){
// 	this.Bstyle=Bstyle;
// 	this.Bssize=Bssize;
// }
// function Phone(Bstyle,Bssize,scolor,ssize,pcolor,pname){
// 	Shell.call(this,scolor,ssize);
// 	Battery.apply(this,[Bstyle,Bssize]);
// 	this.pcolor=pcolor;
// 	this.pname=pname; 
// }
// var phone=new Phone("abvc",1500,'red',2000,'red','诺基亚');
// console.log(phone);



// var obj={
// 	abc:function(){
// 		console.log('我是abc');
// 		return this;
// 	},
// 	xyz:function(){
// 		console.log("我是xyz");
// 		return this;
// 	},
// }
// console.log(obj);


// abc(function(){
// 	console.log("我是abc的一个形参");
// })



// this指向问题
// 1.函数预编译 this-->window
// 2.全局作用域 this-->window
// 3.call/apply 可以改变函数运行时的指向
// 4.obj.func() func()里面的this指向obj


//对象的调用方式
// var obj={
// 	age:123,
// 	fun:function(){
// 		console.log(this.age);
// 	}
// };
// obj.fun();

// var name='222';
// var a={
// 	name:'111',
// 	say:function(){
// 		console.log(this.name);
// 	}
// }
// var fun=a.say;
// fun();  //222
// a.say(); //111
// var b={
// 	name:'333',
// 	say:function(fun){
// 		 fun();
// 	}
// };
// b.say(a.say);  //222
// b.say=a.say;
// b.say();  //333


// var obj={
// 	name:'liliang',
// }
// console.log(obj['name']);


//调对象的另一种方式
// var obj={
// 	name1:'zhao',
// 	name2:'qian',
// 	name3:'sun',
// 	name4:'li',
// }
// function baijia(n){
//   console.log(obj['name'+n]);
// }


// function test(){
// 	'saddsdsad';
// 	console.log(arguments.callee);
// }
// test();
// // arguments返回当前函数的引用
// var jc=(function(n){
// 	if(n==1){
// 		return 1;
// 	}
// 	return n*arguments.callee(n-1);
// }(2));
// callee(arguments)返回当前函数的引用,严格模式不可用
// caller返回当前函数的执行环境(严格模式不可用)函数的属性


// function a(){
// 	b()
// }
// function b(){
// 	console.log(b.caller);
// }
// a();


// 1.原始值 引用值
// 2，区分引用值
// function type(target){
//   var abc={
//   	 '[object number]':'array',
//   	 '[object Object]':'object',
//   	 '[object Number]':"object-number",
//   	 '[object boolean]':'object-boolean',
//   	 '[object String]':'object-string',
//   };
//   var ret=typeof(target);
//   if(target===null){
//   	return 'null';
//   }else if(ret=='object'){
//   	var str=Object.prototype.toString.call(target);
//   	    return abc[str];
//   }else{
//   	return ret;
//   }

// }



// var arr=[323,323,23,215];
// Array.prototype.mpush=function(arr,item){
// 	for(i=0;i<arguments.length;i++){
// 		this[this.length]=arguments[i];
// 	}
// 	return this.length;
// }





//数组去重
// function demo(arr){
// 	arr.sort();
// 	var temp=[arr[0]];
//    for(i=0;i<arr.length;i++){
//        if(arr[i]!=temp[temp.length-1]){
//        	temp.push(arr[i]);
//        }
//    }
//    return temp;
// }
// var arr=[15,15,585,32,45];
// console.log(demo(arr));



//命名空间
//1.
// var lname='liliang';
// var wname='wang';
//2.
// var obj={
// 	team1:{
// 		liliang:{
// 			name:'aaa',
// 		},
// 		zhangsan:{
// 			name:'bbb',
// 		},
// 		lisi:{},
// 	},
// 	team2:{
// 		wangwu:{},
// 	}
// }
// var liliang=obj.team1.liliang;
// console.log(liliang.name);


// 3.闭包函数+立即执行函数
// var team=(function(){
// 	var name='aaa'
// 	var age=23
// 	var obj={
// 		name:'bbb',
// 	}
// 	return function(){
// 		return obj;
// 	}
// }());
// var name='liliang';
// console.log(team().name);




//先执行a如果有错误的地方在执行错误的地方
// 更好地监控报错
// try{
// 	console.log('a');
// 	console.log(b);
// }catch(err){
//   console.log(err.name);
//   console.log(err.message);
// }
// console.log('c');
// console.log('d');
// 报错类型一共有六种:
// 1.ErvalError erval的使用与定义不一致
// 2.RangError 数值越界
// 3.ReferenceError :非法或不能识别的引用值
// 4.SyntaxError 发生语法错误
// 5.TypeError 类型错误
// 6.URLError URL处理函数使用不当



//类型错误
// var obj={}
// obj.push(a);
//未经声明直接赋值的变量可以用delete删除
//声明过的变量无法用delete删除

//1.0 2.0 es6.0(已经有了)
//基于es3.0+es5.0新方法
// es5.0 严格模式
//'use strict': //启动es5严格模式
// b='adfa'
// var a='abc';
// b='xyz';
// a=null;

// function a(){
// 	var a='aaa';
// }


//use strict //启动严格模式
//1.不再兼容es3.0的不规则语法使用全新的es5.0规范
// 2.两种用法
// （1）全局严格模式
// （2）局部函数的严格模式（推荐使用）
// // （3）就是一个字符串不会对不兼容的浏览器产生影响
// （4）不支持with callee caller变量赋值必须声明
// 局部this必须被赋值
// 拒绝重复属性和参数
// 'use strict';
// var name=123;
// function abc(){
// 	var name=234;
// 	console.log(this);
// };
// var obj={
// 	name:456,
// };
// abc.call(obj);

//'use strict';
// function abc(){
// 	'use strict';
// 	b='abc';
// }
// abc();
// 'use strict';
// var name=123;
// function abc(){
// 	this.name=456;
// 	var name=234;
// 	console.log(this.name);
// }
// abc();



// 'use strict';
// function abc(age,age){
   // console.log(age);
// }
// abc(1,2);


// 'use strict';
// var obj={
// 	name:123
// };
// var name=234;
// with(obj){
// 	console.log(name);
// }


//推荐对象取值方式
// var obj={
// 	name:'zhangsan',
// 	age:23,
// 	num:456,
// }
// for(key in obj){
// 	console.log(obj[key]);
// }
// var obj={
// 	name1:'zhangsan1',
// 	name2:'zhangsan2',
// 	name3:'zhangsan3',
// 	name4:'zhangsan4',

// }
// function abc(n){
// 	console.log(obj['name'+n]);
// }

// //对象的枚举（遍历）
// for(key in obj){
// 	console.log(obj[key]);
// }
// 1.hasOwnProperty();是用来判断对象属性是否是自己的
// 2.in 查看属性是否可以被对象使用（不区分自己的还是原型的）
// 3.instanceof 官方定义:a对象是不是b构造函数
// 出来的


//雅虎圣杯继承方方法
//圣杯模式顾名思义:用来继承A对象原型中的成员
// 同时根据自己的需求修改原型对象来构造属于我们要求的构造函数B修改不会对原来对象产生影响
// var extend=(function(){
// 	var F=function(){};
// 	return function(a,b){
// 		F.prototype=a.prototype;
// 		b.prototype=new F();
// 		b.prototype.constructor=b;
// 		b.prototype.uber=a.prototype;
// 	};
// }());



// ABC.prototype={
// 	a:function(){
// 		console.log('我是ABC的方法')
// 	},
// 	b:function(){
// 		console.log("我是ABC的方法")
// 	},

// };
// function ABC(){};
// function Demo(){};
// extend(ABC,Demo);
// Demo.prototype.a=function(){
// 	console.log('我是自己的方法')
// }
// var b=new Demo();
// b.a();
// function C(){};
// extend(ABC,C);
// var c=new C();
// c.a();




// function Girl(){
// 	var age=23;
// 	this.name='貂蝉';
// 	this.say=function(){
//     console.log('我的年纪是'+age+'哈哈');
// 	};

// }
// var diaochan=new Girl();
// diaochan.say();

//时间戳 返回距离1970年前后的秒数
//方法一:
var s=new Date().getTime();
//方法二:
var time=(new Date().valueOf());
//方法三:
var timetamp=Date.parse(new Date());





//数组去重
// 方法一:
// Array.prototype.uniqude=function(){
// 	var obj={};
// 	var  arr=[];
// 	 len=this.length;
// 	for(var i=0;i<len;i++){
// 		if(!obj[this[i]]){
//             obj[this[i]]='abc';
//             arr.push(this[i]);
// 		}
// 	}
// 	return arr;
// }
// var arr1=[1,2,3,2,3];
//  newArr=arr1.uniqude();


//方法二:
// var arr=[1,2,3,2,3];
// // console.log(arr.indexOf(5));
// console.log(myindexOf(arr));
// function abc(){
// 	var newArr=[];
// 	for(i=0;i<arr.length;i++){
// 		if(newArr.indexOf(arr[i])==-1){
// 			newArr.push(arr[i]);
// 		}
// 	}
// 	return newArr;
// }
// var arr=[1,2,3,2,3];
// console.log(abc(arr));



//方法三:
// function xyz(arr){
//    var  ran=arr.sort(function(a,b){
//        return a-b;
//     });
//    var res=[];
//    for(i=0;i<ran.length;i++){
//    	  if(ran[i]!==res[res.length-1]){
//    	  	   res.push(ran[i]);
//    	  }
//    }
//    return res;
// }
// var arr=[1,233,44,44,67,333,2,67];
// console.log(xyz(arr));




//方法一:
// Array.prototype.unique=function(arr){
// 	 var obj={};
//      var arr=[];
//      for(i=0;i<this.length;i++){
//      	if (!obj[this[i]]){
//             obj[this[i]]='abc';
//             arr.push(this[i]);
//      	}
//      }
//      return arr;
// }
// var arr=[1,2,3,4,2,3]; 
// var newArr=arr.unique();
//方法四：双重for循环
//  function uniqude(arr){
//     var res=[arr[0]];
//     for(i=0;i<arr.length;i++){
//     	var ret=false;
//     	for(j=0;j<res.length;j++){
//     		if(arr[i]==res[j]){
//     			ret=true;
//     			break;
//     		}
//     	}
//     	 if(!ret){
//     		res.push(arr[i]);
//     	}
//     }
//     return res;
//  }  
// var arr=[1,2,3,2,3];
// console.log(uniqude(arr));
//数组创建方式
// 1.var arr=[];
// var array=[1] 构造函数创建数组
// var arr=[1,23,4,5];
// arr.splice(1,2);
// splice 第一个参数为要开始替换得下标,
// 第二个为删除元素个数，第三个为要添加的元素
// sort按ASCII码排序
// 1.规则当返回负数时，前面放前面
// 2.当返回正数时，前面放后面
// 3.返回0那就不动
// 升序排序法
//降序排序法
// 正序a-b倒叙b-a
// var arr=[1,2,3,4,42223,3,53];
// arr.sort(function(a,b){
// 	return a-b;
// })
//给对象排序
// var a={age:35};
// var b={age:45};
// var c={age:25};
// var arr=[a,b,c];
// arr.sort(function(a,b){
// 	return a.age-b.age;
// })


//打乱数组
// var arr=[1,2,3,4,5,6,7];
// arr.sort(function(a,b){
// 	return Math.random()-0.5;
// })



//类数组
// 1.属性要为索引属性(数字)属性
// 2.必须有length方法
// 3.最好要有push方法
// 4.加上splice会更像数组
//类数组



//如何进行深度克隆
// 1.判断属性值是不是原始值 typeof
//2.判断数组还是对象 instanceof
// toString() constructor (iframe)内联框架
//3.创建数组或对象
// 4.递归函数
// function myClone(origin,target){
// 	if(origin!==null || typeof(target)==='function' || typeof(origin)==='object'){
// 		return origin;
// 	}
// 	var target=target || {};
// 	var toString=Object.prototype.toString;
// 	var arrstr='[Object Array]';
// 	for(key in origin){
// 		if(origin.hasProperty(key)){
// 			if(toString.call(origin[key])==arrstr){
// 				origin[key]=[];
// 			} 
			
// 			else{
// 				origin[key]={};
// 			}
// 			myClone(origin[key],target[key]);
          
// 		}
// 		 origin[key]=target[key];
// 	}
//    return origin;
// }
// var a={
// 	name:{
// 		n1:[1,2,3,{
// 			sex:'aa'
// 		}],
// 		n2:'002'},
// 		age:25
// }
//  var c=[123,[1,2,3],{age:24}];
// var b=myClone(c);
// console.log(b);
// console.log(a);

// var a={
// 	name:{
// 		n1:[1,2,3,{
// 		sex:'lili'
// 	}],
// 	n2:'002'},
// 	age:25
// }
// var b=myClone(a);
// console.log(b);


// var a={
// 	name:{
// 		n1:[1,2,3,
// 		{sex:'li'
// 	}],
// 	n2:'002'},
// 	age:25
// }
// var c=myClone(a);
// console.log(c);


//正则对象
//match可在字符串检索到指定的值返回一个数组
// 或找到一个或多个正则表达式的匹配
//i执行对大小写不敏感的匹配
//m执行多行文本框的匹配
// g执行与a有关的匹配
// ^除当前之外的
//\n代表换行符
//\r代表结束符
//\w查找单词字符 数字字母下划线 0-9 A-Z
// a-z
// \t制表符代表四个空格
// \d匹配0-9
//\s查找空白字符
//\S===\n\r\t\f\v+空格
//\S===!s
//\b寻找单词边界(一个单词有两个边界)
//  \uxxxx查找以十六进制xxxx规定的unicode字符
// +至少出现一次或多次
// *至少出现0次或多次
//？至少出现0次或一次
//test检索字符串中指定的值，返回true或false
//exec检索字符串中指定的值返回找到的值，并确定其位置
//last index标记下一次匹配字符开始的位置
// \$匹配字符串结尾位置
// ()标记一个字符串的结尾和开始位置
// .查找单个字符，除了换行和行结束符
// [标记一个中括号表达式的开始
// {标记限定符表达式的开始
// |指明两项之间的一项选择
// {n}是一个非负整数，匹配确定的n次
// {n,}至少匹配n次
//{n,m}至少匹配n次至多匹配m次
// 除当前之外三个字母的单词
// var reg=/^\w{3}/g;
// var tel='abcdds'
// console.log(tel.match(reg));

// var reg=/(^1[3578][0-9]{9})/g;
// var str='hkhksskd134522462352';
// console.log(str.match(reg));


// var reg=/$/g;
// var tel='123abc';
// console.log(tel.match(reg));


// var reg=/1[3587]/g;
// var tel='13931688553';  //  
// console.log(tel.match(reg));

// var reg=/^1[3456789][0-9]{9}$/
// var tel='adsdssdsddds13931688858';
// console.log(tel.match(reg));

// var reg=/[s]?/g;
// var tel='ssladasssasdas';
// console.log(tel.match(reg));

// var reg=/(\w)(\w)\1\2/g;
// var tel='ddddsssa12333';
// console.log(tel.match(reg));

// var reg=/ab/g;
// var tel='abaasxab'
// console.log(reg.exec(tel));
// console.log(reg.lastIndex);
// console.log(reg.exec(tel));
// console.log(reg.lastIndex);
// console.log(reg.exec(tel));
// console.log(reg.lastIndex);


// var reg=/(4)/g;
// var tel='2344488874651';
// var con=0;
// document.write(tel.replace(reg,function($,$1){
// 	con++;
// 	var num=Number($1)*con;
// 	return num;
// }));
// console.log(tel.match(reg));


</script>
</body>
</html>
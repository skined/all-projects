<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title></title>
</head>
<body>
<script src="jquery.js"></script>
<script type="text/javascript">
// var a='Nothing is impossible(没有什么是不可能的)';
// document.write(a);
	// 对象是什么  万物皆对象
	// var obj	={
	// 	name:"xiaolong",
	// 	age:23,
	// 	health:100,
	// 	smoke:function(){
	// 		obj.health--;
	// 		console.log("o0o");
	// 	},
	// 	drink:function(){
	// 		obj.health++; 
	// 		console.log("干杯！");
	// 	}
	// };
// 2.属性的增删改查
// obj.sex='男';
// console.log(obj.sex);
// //删除方法
// delete obj.age
// console.log(obj);
// 3.对象的创建方式有两种
// （1）对象字面量/对象直接量
// （2）构造函数
//    （1系统自带的构造函数
//    （2自定义的构造函数
 // var obj=new Object();
 // console.log(typeOf(obj));
//构造函数
//构造函数需要大驼峰命名方式
 // function Test(){
 // 	this.name='lixiaolong';
 // 	this.age=23;
 // 	this.sex='nan';
 // 	this.health=100;
 // 	this.say=function(){
 // 		alert("123");
 // 	};
 // 	this.smoke=function(){
 // 		health--;
 // 	}
 // }
 //   var obj=new Test();
 //   // var obj1=new Test();
 //   obj.age=24;
 //   console.log(obj.smoke);

  //每实例化一次，创建一个新的对象
  //构造函数内部原理
//   构造函数构建出对象时，需要new,有了new之后会产生构造函数的三段式
// 1.在函数的最前面创建隐式this={};
// 2.执行this.name=”liliang”，给this附属性
// 3.隐式三段返回this
//4.在构造函数new实例的时候，如果内部return的是值类型，会被忽略，而引用类型
//会影响对象的属性
// function Person(name,age,height){  //Person不是一个方法 不可直接调用
// 	this.name=name;
// 	this.age=age;
// 	this.height=height;
// 	return ;
// }   
// var luBu=new Person('吕布',32,220);
// var luzshen=new Person('鲁智深',35,190);
// var wus=new Person('武松',32,185);
// 字符串调数组的方法
// name调数组的方法



// var m=new Number(123);
// m=m+1;
// console.log(typeof m);
//包装类
// 1.new Number();
// 2.new String();
// 3.new Boolean();

 // var str='abcd';
 // str.length=2;
 // console.log(str.length);
// 1.new String('abcd').length=2;
// 2.delete  取length，给length赋值，然后删除

// console.log(str.length);
// 1.new String('abcd').length
// 2.delete


// var x=1;
// var y=z=0;
// function add(n){
//    return n=n+1;
// }
// y=add(x);
// function add(n){
// 	return n=n+3;
// }
// z=add(x);
// console.log(x,y,z);
// 求xyz?





// var str='abc';
//  str+=1;
// // var str=str+1='abc'+1;
//  var test= typeof(str); 
//  // console.log(test);
//  // new String('abc').length;
// // delete
// if(test.length==6){
// 	test.sign='我是string';
// }
// console.log(test.sign);






// function Person(name,age){
// 	var a=0;
// 	// this.name=name;
// 	function ccc(){
// 		a++;
// 		console.log(a);
// 	}
// 	this.say=ccc;
// }
// var person=new Person();
// person.say();

// charcodeAt() //0~65535  unicode码的位置
// var str='asdfiasffuusdufol大方公开快速打开'
// unicode 0-255  1B
// unicode 255以上 2B
// function abc(str){
// 	 var num=0;
// 	for(i=0;i<str.length;i++){
// 	if(str[i].charCodeAt<=255){
		
//        num++;
// 	}else{
// 		num+=2;
// 	}
// }
// return num;
// }
// console.log(abc('asdfiasffuusdufol大方公开快速打开'));

 
 // console.log(isNaN('dsa'));


// function demo(a){
// 	 if(typeof a=='number' || typeof a=='boolean'){
// 		console.log('false');
// 	}else if(typeof a=='object' || typeof a=='undefined' || typeof a != 'number'){
// 		console.log('true');
// 	}
// 	}
// demo(true);


// 方法二：
// isNaN('ADSADD');
// function myIsNaN(str){
// 	var isN=Number(str);
// 	isN+='';
// 	if(isN=='NaN'){
// 	 return true;
// 	}
// 	else{
// 		return false;
// 	}
// }
// console.log(myIsNaN(true));


// 引用值可以操作属性 数组带砍断属性 原型不能操作属性
// var arr=[1,2,3,4,5]
// console.log(arr.length);
// arr.length=3;
// console.log(arr);



// 原型/原型链
// 1.定义：原型是function对象的一个属性，它定义了构造函数制造出来的对象的共有祖先.通过该函数产生的对象，可以继承该原型的属性和方法，原型也是个对象
// 2.利用原型特点可以提取共有属性
// 3.对象如何查看原型_proto_(隐式属性)
// 4.对象查看对象的构造函数 constructor
//增删改查只有查可以简单读取原型中的属性
//原型是实例出来构造函数制造出来对象的共有祖先
// console.log(Person .prototype)    //prototype原型类型
// Person.prototype.name='比利王去世';
// function Person(){
//  this.name='xyz';	

// }
// var obj=new Person();
// console.log(obj.name);
// console.log(Person.prototype.name);  //原型是函数的一个属性，调用函数的属性在该函数中没有时可以调用原型函数中的属性



// Car.prototype.name='BMW';
// Car.prototype.height=140;
// Car.prototype.lang=400;
// function Car(color){
// 	//this.name='BMW';
// 	// this.height=140;
// 	// this.lang=400;
// 	   this.color=color;
// }
// var car=new Car('red');
// var car1=new Car('red');
// var car2=new Car('red');


// Car.prototype={
// 	name:'BMW',
// 	height:140,
//     lang:400,
// }
// function Car(color){
//     this.color=color;	
// }
// var obj=new Car('red');
//  	 obj.name='奔驰';
// 	console.log(obj); //对象查找函数调用constructor



 // Car.prototype.lang = 400;
 //            function Car(color) {}
 //             Car.prototype = {lang: 500};
 //               var obj = new Car();
           

 //            console.log(obj.lang);                         
// Car.prototype.lang=400;
// Car.prototype.lang=500;
//  Car.prototype.constructor=Car;
//   Car.prototype.constructor=Person;
// function Person(){

// }
// function Car(){

// }
// var obj=new Car();
// console.log(obj.constructor);  //对象查找构造函数调用constructor



// Car.prototype.lang=400;
// function Car(){	
// 	__proto__:Car.prototype		
// }
// var obj=new Car();
// console.log(Car.prototype);  //构造函数查找原型调用prototype
// console.log(obj.__proto__);  //对象查找原型调用__proto__
// console.log(obj.constructor);
// 上述两种方法都指向同一种原型prototype
//constructor后天可以更改



// Object.prototype.age=23;
// Object.prototype.age=24;
// Car.prototype.lastname='liu';
// function Car(){
// 	this.name='wang';
// }
// var obj=new Car();
// obj.firstname='zhang';
// console.log(obj.__proto__.firstname);


// Car.prototype.name='lll';
// Car.prototype.lang=123;
// function Car(){
//   console.log(Car.prototype)
// }
// //  var str=new String('abc');
// var obj=new Car();
// obj.__proto__.name='ddd';
// console.log(obj.__proto__);
// 原型链
// 1.如何构成原型链
// 2.原型链的增删改查
// 3.绝大多数的对象都会继承Object.prototype(object.prototype是最终端)
// 4.Object.craete();
// var obj=Object.create(null);  //特例，传null也是原始对象，
// console.log(obj); 
//除null之外，别的传参数都不好找
// 原型链一级一级往上找，自有用自己的没有往上找

// Grand.prototype.lastName='li';
// function Grand(){}
// var grand=new Grand();
// Father.prototype=grand;
// function Father(){
// 	  this.name='liang';
// }
// var father=new Father();
// Son.prototype=father;
// function Son(){
// 	this.smoke='smoking';
// }
// var son=new Son();
// console.log(son.smoke);  
// console.log(son.name);   
// console.log(son.lastName);


// null是唯一没有对象的原型
//再次添加属性时又会在创建一个新的原型
// var obj=Object.create({});
// obj.__proto__={
// 	name:'li'
// };
// // obj={
// // 	name:'wang',
// // };
//  obj.name='shang';
// console.log(obj);



// var obj=Object.create({});
// obj.name='wang';
// obj.toString=function(){
// // 	'[Object Object]'
// console.log('hahaha');
//  }
// obj.toString();
// var  num=123;
// num.toString();



// Number.prototype.toString=function(){
// 	console.log('hehehe');
// }
// String.prototype.toString=function(){
// 	console.log('heihei');
// }
// var str=new String('abc');
// console.log(str.__proto__.__proto__);

// call和apply的区别及应用
// 作用:改变this指向，不同:传参形式不同
// apply传参传的是数组，call传的是一个一个的参数
//call可以传多个参数,apply是以数组的形式进行传参
// function test(){
//   alert();
// }
// test()=test.call();
// call的用法如下：
// function Person(name,age){
// 	this.name=name;
// 	this.age=age;
// }
// function Abc(){
// 	this.tel=515151215;
// }                   
// var obj=new Abc();
// Person.call(obj,'fd',25);
// apply的用法如下:
// function Person(name,age){
// 	this.name=name;
// 	this.age=age;
// 	this.sex=sex;
// 	this.height=height;
// }
// function Abc(){
// 	this.tel=13835325815;
// }
// var obj=new Abc();
// Person.apply(obj,['long',25]);



// function Person(name,age,sex){
// 	this.name=name;
// 	this.age=age;
// 	this.sex=sex;
	
// }
// function Student(name,age,sex,tel){
// 	  	//Person.call(this,name,age,sex);
// 	     this.tel=tel;
// }
// var student=new Student('LI',28,'nan',1354564);
//    Person.apply(student,['LI',28,'nan']);
//   Person.call(student,'Li',25,'nan');
//   console.log(student);
//将Person里边的this属性指向student里边的this属性



// Object.prototype.toString.call(123);
// Object.prototype.toString.call('abc');
// Object.prototype.toString.call([1,2,3]);
// Object.prototype.toString.call({});
//  Number.prototype.toString=function(){
// 	var str='';
// 	str+=this;
// 	return str;
// }
// var num=123;
// console.log(num.toString());

// function Shell(scolor,ssize){
// 	this.scolor=scolor;
// 	this.ssize=ssize;
// }
// function Battery(Bstyle,Bsize){
// 	this.Bstyle=Bstyle;
// 	this.Bsize=Bsize;
// } 
// function Phone(Bstyle, Bsize, scolor, ssize, pcolor, pname) {
//    Shell.call(this,scolor,ssize);
//    Battery.apply(this,[Bstyle,Bsize]);
//     this.pcolor = pcolor;
//     this.pname = pname;
// }
// var phone=new Phone('abvc',1500,'red',2000,'red','诺基亚');
// console.log(phone);



// var obj={
// 	abc:function(){
// 		console.log('我是abc');
// 		return this;
// 	},
// 	xyz:function(){
// 		console.log('我是xyz');
// 		return this;
// 	},
// }
// $('#but').click(funciton(){
// 	$(this).hide();
// })
// $('#but').click(function(){
// 	#(this).hide()
// })
// function abc(){
// 	fun();
// }
// abc(function(){
// 	console.log('我是abc的一个形参')
// })

// this指向问题  
// 1.函数预编译过程 this-->window
// 2.全局作用域this-->window
// 3.call/apply 可以改变函数运行时的指向
// 4.obj.func()  func()里面的this指向obj


// var name=123;
// function abc(){


// 	var name=234;
// 	console.log(this.name);
// }
// abc();

//对象调用方式
// var obj={
//   age:123,
//   fun:function(){
//   	console.log(this.age);
//   }
// };
// obj.fun();


// var name = '222';
//   var a = {
//       name:"111",
//       say:function(){
//           console.log(this.name);
//       }
//   }
//   var fun = a.say;
//   fun();  //222
//   a.say();  //111 
//   var b = {
//       name :"333",
//       say:function(fun){
//           fun();
//       }
//   };
//   b.say(a.say);  //222
//   b.say = a.say; 
//   b.say();      //333



//封装一个和typeof同样功能的函数
// function myTypeof(value){
//   if(typeof(value)=='number'){
//   	console.log(Number);
//   }
//   if(typeof(value)=='string'){
//   	console.log(String);
//   }
//   if(typeof(value)==true,false){
//   	console.log(Boolean);
//   }
//   else if(typeof(value)=='undefined'){
//   	console.log(undefined);
//   }
//   if(typeof(value)=='function','Array','object','null'){
//   	console.log(Object);
//   }
//   return typeof(value);
// }
// console.log(myTypeof(null));
// console.log(typeof undefined);



// var obj={
// 	name:'liliang',
// }
// console.log(obj['name']);

//调对象属性的另一种方式
// var obj={
// 	name1:'zhao',
// 	name2:'qian',
// 	name3:'sun',
// 	name4:'li',
// }
// function baijia(n){
// 	console.log(obj['name'+n])
// }


// function test(){
//    'sdadsaadsa';
//    console.log(arguments.callee);
// }
// test();

// arguments callee 返回当前函数的引用
// var jc=(function(n){
// 	if(n==1){
// 		return 1;
// 	}
// 	return n*arguments.callee(n-1);
// }(5));
// callee 返回当前函数的引用(严格模式不可用)  arguments的属性
// caller 返回当前函数的执行环境(严格模式不可用) 函数的属性

// function a(){
// 	b();
// }
// function b(){
// 	console.log(b.caller);
// }
// a();


// function a(){
// 	var a=Object.prototype.toString.call(arguments);
// 	console.log(arguments);
// }
// console.log(a());

// 1.原始值 引用值
// 2.区分引用值
// function type(target){
//     var abc={
//     	'[object Array]':'array',
//     	'[object Object]':'object',
//     	'[object Number]':'obj-number',
//     	'[object String]':'obj-string',
//     	'[object Boolean]':'obj-boolean',
//     };
//     var ret=typeof(target);
// 	if(target===null){
// 		return 'null';
// 	}else if(ret=='object'){
// 		var str=Object.prototype.toString.call(target);
//          return abc[str];
// 	}else{
// 		return ret;
// 	}
// }







// var arr=[13,32,33];
// Array.prototype.mpush=function(arr,item){
//    for(i=0;i<arguments.length;i++){
//      this[this.length]=arguments[i];
//    }
//    return this.length;
// }
// 	var obj={
// 		a:
// }


// function b(n){
//     n();
// }

// b();
// n();





//小练习
// var a=10;
// var b=++a-1+a++;
// var b=10+11;
// console.log(b+''+a);


// 命名空间
// 1.var lname='liliang';
  // var wname='wang';
  // 2.
  // var obj={
  // 	team1:{
  // 		liliang:{
  // 			name:'aaa',
  // 		},
  // 		zhangsan:{
  // 			name:'bbb',
  // 		},
  // 		lisi:{},
  // 	},
  // 	team2:{
  // 		wangwu:{},
  		
  // 	}
  // }
  // var liliang=obj.team1.liliang;
  // console.log(liliang.name);


  // 2.闭包+立即执行函数
  // var team=(function(){
  // 	var name='aaa'
  // 	var age=23
  // 	var obj={
  // 	  name:'bbb',
  // 	}
  // 	var obj1={
  // 		name:'ccc',
  // 	}
  // 	return function(){
  // 		return obj;
  // 	}
  	
  // }()); 
  //  var name='liliang';
  //  console.log(team().name);

  
// 先执行a如果有错误的地方在执行错误的区域更好地监控报错
   // try{
   // 	console.log('a');
   // 	console.log(b);
   // 	var obj={}
   //  obj.push(a);
   // }catch(err){
   //  console.log(err.name);
   //  console.log(err.message);
   // }
   // console.log('c');
   // console.log('d');
   // error.name一共六种
   // 1.ErvalError     erval的使用与定义不一致(不常见)
   // 2.RangError      数值越界
   // 3.ReferenceError:非法或不能识别的引用值
   // 4.SyntaxError    发生于语法错误
   // 5.TypeError      类型错误
   // 6.URLError       URL处理函数使用不当




//类型错误
 // var obj={};
 // obj.push(a);
// 未经声明直接赋值的变量可以用delete删除
//声明过的变量无法用delete删除

// 1.0 2.0   es6.0(已经有了)
// 基于es3.0+es5.0新方法
// es5.0 严格模式
//  'use strict' //启动es5严格模式
// b='afda'
// var a='abc';
// b='xyz';
//    a=null;

// function a(){
// 	var a='aaa';
// }


//use strict//启动es5严格模式
//1.不再兼容es3.0的不规则语法使用全新的es5.0规范
//2.两种用法
// （1）全局严格模式
// （2）局部的函数内严格模式（推荐使用）
// （3）就是一个字符串不会对不兼容的浏览器产生影响
// （4）不支持with，callee,caller  
//    变量赋值前必须声明
//    局部this必须被赋值
//    拒绝重复属性和参数
// function abc(){
// 	'use strict';
// 	 b='abc';
// }
// abc();


//  "use strict";
// var name = 123;
//             function abc() {
//                 var name = 234;
//                 console.log(this);
//             };
//             var obj = {
//                 name:456
//             };
//             abc.call(obj);




//  "use strict";
// function abc(age,age){
// 	console.log(age);
// }
// abc(1,2);
	
	
//  'use strict';
// function abc() {
//                 console.log(arguments.callee);
//            }
//            abc();

// 'use strict';
//   var obj = {
//          name:123
//           };
//   var name = 234;
// with(obj){
//     console.log(name);
// }

</script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title></title>
	<style type="text/css">
		
	</style>
</head>
<body>
	
<!-- 面向过程 
面向对象特点：
抽象:抓住事物核心的东西，象：具象
封装：
继承：
多态js弱类语言，它不像Java-->

<script type="text/javascript">
// 基本写法                                   
  // var obj={};
  // var obj=new Object();//创建一个空对象
  // // var arr=new Array();//length,push,sort
  // obj.name='lee';
  // obj.age="40";
  // obj.getName=function(){
  // 	console.log(this.name+this.age);
  // }
  // obj.getName();
  //为了解决基本写法的代码量过大，所以衍生出工厂方式
  // function CreatePerson(name,age){
  //      this.name=name;
  //      this.age=age;
  //      // 出厂
  // }
  // // 方法挂载到了构造函数的上面
  //  CreatePerson.prototype.getName=function(){
  //      	console.log(this.name+this.age);
  //      }
  // var p1= new CreatePerson('leo',40);
  // p1.getName();
  
  // var p2=new CreatePerson('lee',42);
  // p2.getName();
  // console.log(p1.getName()==p2.getName());
  //1.我们写的缺什么 1.函数字母没有大写
  //2.我们没有new
  //3.new后面调用的函数叫构造函数 在函数里面创建对象和返回对象的过程js已经帮我们执行了（隐式返回）
  //构造函数里面的this指向实例化出来的对象
  //构造函数和普通函数的区别：
    //1.函数名大小写不同
    //2.构造函数也是函数，只不过调用方式不同，
    //必须要用new运算符来调用
    //this:在全局范围内调用，this指向window，在构造函数内指向当前构造函数实例化出来的对象
    // prototype主要作用是挂载对象的共有属性和方法
   
       
function sum(num){
	for(i=1;i<6;i++){
       num=num*2+1;
	}
	return num;
}




</script>
</body>
</html>